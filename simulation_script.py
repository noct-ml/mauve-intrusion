'''Mauve Intrusion: Quantifying Coherence in Coupled Chaotic SystemsAuthor: James Jones'''import numpy as npfrom scipy.integrate import odeintfrom scipy.stats import pearsonrfrom scipy.fft import fft, fftfreqimport matplotlib.pyplot as pltfrom matplotlib.colors import LogNorm# Lorenz systemdef lorenz(state, t, sigma=10, rho=28, beta=8/3):    x, y, z = state    dx = sigma * (y - x)    dy = x * (rho - z) - y    dz = x * y - beta * z    return [dx, dy, dz]# Lorenz Jacobiandef lorenz_jac(state, sigma=10, rho=28, beta=8/3):    x, y, z = state    return np.array([[-sigma, sigma, 0],                     [rho - z, -1, -x],                     [y, x, -beta]])# Rössler systemdef rossler(state, t, a=0.2, b=0.2, c=5.7):    x, y, z = state    dx = -y - z    dy = x + a * y    dz = b + z * (x - c)    return [dx, dy, dz]# Rössler Jacobiandef rossler_jac(state, a=0.2, b=0.2, c=5.7):    x, y, z = state    return np.array([[0, -1, -1],                     [1, a, 0],                     [z, 0, x - c]])# Function to compute eigenvalues-based MI from trajectory and Jacobian functiondef compute_mi(traj, jac_func, params):    R = np.zeros(len(traj))    B = np.zeros(len(traj))    G = np.zeros(len(traj))    for i in range(len(traj)):        J = jac_func(traj[i], **params)        eigs = np.sort(np.real(np.linalg.eigvals(J)))        R[i] = max(0, eigs[2])        B[i] = max(0, -eigs[0])        G[i] = abs(eigs[1])    R_max = np.max(R) if np.max(R) > 0 else 1    B_max = np.max(B) if np.max(B) > 0 else 1    G_max = np.max(G) if np.max(G) > 0 else 1    R /= R_max    B /= B_max    G /= G_max    eps = 1e-10    R = np.clip(R, eps, None)    B = np.clip(B, eps, None)    G = np.clip(G, eps, None)    MI = (R * B) / (R + B)**2 * np.exp(-G / np.sqrt(R * B))    return MI# Driven Rössler with MI modulationdef rossler_driven(state, t, mi_interp, k=0.02, a0=0.2, b=0.2, c=5.7):    a = max(0.1, a0 + k * mi_interp(t))    return rossler(state, t, a=a, b=b, c=c)# Local Shannon entropydef local_shannon_entropy(traj, window_size=200, bins=5):    entropy = np.zeros(len(traj) - window_size)    for i in range(len(entropy)):        window = traj[i:i+window_size]        hist, _ = np.histogramdd(window, bins=(bins, bins, bins))        hist = hist / hist.sum()        hist = hist[hist > 0]        entropy[i] = -np.sum(hist * np.log(hist))    return entropy# Power spectrumdef power_spectrum(signal, dt=0.01, freq_range=(0,5)):    N = len(signal)    yf = fft(signal)    xf = fftfreq(N, dt)[:N//2]    power = 2.0 / N * np.abs(yf[:N//2])    mask = (xf >= freq_range[0]) & (xf <= freq_range[1])    peak_freq = xf[mask][np.argmax(power[mask])]    # Data-driven cutoff: assume midpoint for simplicity, adjust as needed    cutoff = (freq_range[0] + freq_range[1]) / 2    low_power = np.sum(power[(xf < cutoff)])    high_power = np.sum(power[(xf >= cutoff)])    turbulence_ratio = high_power / low_power if low_power > 0 else np.inf    return xf[mask], power[mask], peak_freq, turbulence_ratio# Phase-space densitydef phase_space_density(traj, MI, bins=50):    x, z = traj[:,0], traj[:,2]    hist, xedges, zedges = np.histogram2d(x, z, bins=bins)    mi_mean = np.zeros((bins, bins))    counts = np.zeros((bins, bins))    for i in range(len(traj)):        xi = np.digitize(x[i], xedges) - 1        zi = np.digitize(z[i], zedges) - 1        if 0 <= xi < bins and 0 <= zi < bins:            mi_mean[xi, zi] += MI[i]            counts[xi, zi] += 1    mi_mean[counts > 0] /= counts[counts > 0]    return xedges, zedges, mi_mean# Approximate FTLEs via perturbationsdef approx_ftles(traj, ode_func, params, window_size=200, tau=0.1, delta=1e-6):    ftles = np.zeros((len(traj) - window_size, 3))  # 3 directions    t_short = np.linspace(0, tau, 10)    for i in range(len(ftles)):        state = traj[i]        # Evolve nominal        _ = odeint(ode_func, state, t_short, args=params)        for d in range(3):            pert = np.zeros(3)            pert[d] = delta            state_pert = state + pert            traj_pert = odeint(ode_func, state_pert, t_short, args=params)            dev = np.linalg.norm(traj_pert[-1] - traj[i + len(t_short) - 1]) / delta            ftles[i, d] = np.log(dev) / tau if dev > 0 else 0    return ftles# Bleed metricsdef bleed_metrics(MI, ftles):    mean_mi = np.mean(MI)    mixed_fraction = np.mean(np.any(ftles > 0, axis=1) & np.any(ftles < 0, axis=1))    return mean_mi, mixed_fraction# Main simulationdt = 0.01t = np.arange(0, 1100, dt)  # Extra for transientsstate0 = [1.0, 1.0, 1.0]# Simulate Lorenztraj_lor = odeint(lorenz, state0, t)[10000:]  # Discard 100 unitst_sim = t[10000:]MI_lor = compute_mi(traj_lor, lorenz_jac, {'sigma':10, 'rho':28, 'beta':8/3})# Interpolate MIfrom scipy.interpolate import interp1dmi_interp = interp1d(t_sim, MI_lor, bounds_error=False, fill_value="extrapolate")# Simulate driven Rösslertraj_ross_driven = odeint(rossler_driven, state0, t_sim, args=(mi_interp,))MI_ross = compute_mi(traj_ross_driven, rossler_jac, {'a':0.2, 'b':0.2, 'c':5.7})  # Use average a for jac# Simulate uncoupled Rössler for comparisontraj_ross_unc = odeint(rossler, state0, t_sim)# Analyses for Lorenz# 1. Trajectories (Fig 1)plt.figure()plt.plot(t_sim[:5000], traj_lor[:5000, 0], label='x')plt.plot(t_sim[:5000], traj_lor[:5000, 1], label='y')plt.plot(t_sim[:5000], traj_lor[:5000, 2], label='z')plt.legend()plt.title('Lorenz Attractor Trajectories')plt.savefig('fig1.png')# 2. MI vs z (Fig 2)plt.figure()plt.scatter(MI_lor, traj_lor[:,2], s=1)plt.title('MI(t) vs z Phase Map (Mauve Loops)')plt.savefig('fig2.png')# 3. Entropy correlation (Fig 3)entropy_lor = local_shannon_entropy(traj_lor)corr, _ = pearsonr(MI_lor[:-200], entropy_lor)plt.figure()plt.plot(t_sim[:-200], MI_lor[:-200], label='MI(t)')plt.plot(t_sim[:-200], entropy_lor, label='Entropy')plt.legend()plt.title(f'Weak Correlation of MI(t) and Local Shannon Entropy (r={corr:.2f})')plt.savefig('fig3.png')# 4. Power spectrum (Fig 4)xf, power, peak, turb_ratio = power_spectrum(MI_lor)plt.figure()plt.plot(xf, power)plt.title(f'Power Spectrum of MI(t) (0-5 Hz) with Turbulence Ratio {turb_ratio:.1f}')plt.savefig('fig4.png')# 5. Parameter modulation (Fig 5) - a(t)a_t = np.array([max(0.1, 0.2 + 0.02 * mi_interp(ti) ) for ti in t_sim])plt.figure()plt.plot(t_sim[:5000], a_t[:5000])plt.title('Parameter Modulation a(t) Driven by MI(t)')plt.savefig('fig5.png')# 6. Driven vs standard Rössler (Fig 6)plt.figure()plt.subplot(2,1,1)plt.plot(t_sim[:5000], traj_ross_driven[:5000, 0], label='x driven')# Add y, zplt.title('Driven Rössler Dynamics Under MI Modulation vs. Standard')plt.subplot(2,1,2)plt.plot(t_sim[:5000], traj_ross_unc[:5000, 0], label='x standard')# Add y, zplt.savefig('fig6.png')# 7. Phase-space density (Fig 7)xedges, zedges, mi_mean = phase_space_density(traj_ross_driven, MI_lor)plt.figure()plt.pcolormesh(xedges, zedges, mi_mean.T, norm=LogNorm())plt.colorbar()plt.title('Phase-Space Density: The Mauve Corridor (x-z plane)')plt.savefig('fig7.png')# 8. Lorenz bleed plots (Fig 8)ftles_lor = approx_ftles(traj_lor, lorenz, (10,28,8/3))mean_mi_lor, frac_lor = bleed_metrics(MI_lor, ftles_lor)plt.figure(figsize=(10, 6))plt.subplot(2,1,1)plt.plot(t_sim[:5000], traj_lor[:5000, 0], label='x')plt.plot(t_sim[:5000], traj_lor[:5000, 1], label='y')plt.plot(t_sim[:5000], traj_lor[:5000, 2], label='z')plt.legend()plt.title('Lorenz Trajectories')plt.subplot(2,1,2)plt.plot(t_sim[:5000], MI_lor[:5000], label='MI(t)', color='blue')plt.legend()plt.title('Mauve Intrusion MI(t)')plt.tight_layout()plt.savefig('fig8.png')# 9. Rössler bleed plots (Fig 9)ftles_ross = approx_ftles(traj_ross_driven, rossler_driven, (mi_interp,))  # Approximate with fixed amean_mi_ross, frac_ross = bleed_metrics(MI_ross, ftles_ross)plt.figure(figsize=(10, 6))plt.subplot(2,1,1)plt.plot(t_sim[:5000], traj_ross_driven[:5000, 0], label='x', color='blue')plt.plot(t_sim[:5000], traj_ross_driven[:5000, 1], label='y', color='orange')plt.plot(t_sim[:5000], traj_ross_driven[:5000, 2], label='z', color='green')plt.legend()plt.title('Rössler Trajectories')plt.subplot(2,1,2)plt.plot(t_sim[:5000], MI_ross[:5000], label='MI(t)', color='blue')plt.legend()plt.title('Mauve Intrusion MI(t)')plt.tight_layout()plt.savefig('fig9.png')# Sensitivity analysisk_values = np.arange(0, 0.051, 0.005)variances = []corrs = []for k in k_values:    def rossler_k(state, t):        return rossler_driven(state, t, mi_interp, k=k)    traj_k = odeint(rossler_k, state0, t_sim)    var = np.var(traj_k[:,0]) / np.var(traj_ross_unc[:,0])  # Normalized amplitude variance for x    corr_k = pearsonr(MI_lor, traj_k[:,0])[0]    variances.append(var)    corrs.append(corr_k)# Plot or print resultsprint("Sensitivity: variances", variances)print("Correlations", corrs)# Cross-entrainment metricsamp_var_red = (np.var(traj_ross_unc[:,0]) - np.var(traj_ross_driven[:,0])) / np.var(traj_ross_unc[:,0]) * 100x_corr = pearsonr(traj_lor[:,0], traj_ross_driven[:,0])[0]print(f"Amplitude variance reduction: {amp_var_red:.0f}%")print(f"x-correlation: {x_corr:.2f}")# Bleedprint(f"Lorenz mean MI: {mean_mi_lor:.4f}, fraction: {frac_lor:.3f}")print(f"Rössler mean MI: {mean_mi_ross:.4f}, fraction: {frac_ross:.3f}")